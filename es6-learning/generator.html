<!DOCTYPE html>
<html>

<head>
    <title></title>
</head>

<body>
    <script type="text/javascript">
    (function() {
        'use strict';


        // 这看上去很像一个函数，这被称为 Generator 函数，它与我们常见的函数有很多共同点，但还可以看到下面两个差异：
        //通常的函数以 function 开始，但 Generator 函数以 function* 开始。
        //在 Generator 函数内部，yield 是一个关键字，和 return 有点像。不同点在于，所有函数（包括 Generator 函数）都只能返回一次，而在 Generator 函数中可以 yield 任意次。yield 表达式暂停了 Generator 函数的执行，然后可以从暂停的地方恢复执行。
        //常见的函数不能暂停执行，而 Generator 函数可以，这就是这两者最大的区别。

        function* quips(name) {
            yield "hello " + name + "!";
            yield "i hope you are enjoying the blog posts";
            if (name.startsWith("t")) {
                yield "it's cool how your name starts with t, " + name;
            }
            yield "see you later!";
        }

        var iter = quips('tang');
        console.log(iter.next().value);
        console.log(iter.next().value);
        console.log(iter.next().value);
        console.log(iter.next().value);
        console.log(iter.next().value);

        // 调用quips();
        // > var iter = quips("tang");
        //   [object Generator]
        // > iter.next()
        //   { value: "hello tang!", done: false }
        // > iter.next()
        //   { value: "i hope you are enjoying the blog posts", done: false }
        // > iter.next()
        //   { value: "see you later!", done: false }
        // > iter.next()
        //   { value: undefined, done: true }


        // 从技术层面上讲，每当 Generator 函数执行遇到 yield 表达式时，函数的栈帧 – 本地变量，函数参数，临时值和当前执行的位置，就从堆栈移除，但是 Generator 对象保留了对该栈帧的引用，所以下次调用 .next() 方法时，就可以恢复并继续执行。

        // 值得提醒的是 Generator 并不是多线程。在支持多线程的语言中，同一时间可以执行多段代码，并伴随着执行资源的竞争，执行结果的不确定性和较好的性能。而 Generator 函数并不是这样，当一个 Generator 函数执行时，它与其调用者都在同一线程中执行，每次执行顺序都是确定的，有序的，并且执行顺序不会发生改变。与线程不同，Generator 函数可以在内部的 yield 的标志点暂停执行。

        // 通过介绍 Generator 函数的暂停、执行和恢复执行，我们知道了什么是 Generator 函数，那么现在抛出一个问题：Generator 函数到底有什么用呢？

        console.log('------------------------------------');

        // 实现一个 range(start,stop) 迭代器
        // class RangeIterator {
        //     constructor(start, stop) {
        //         this.value = start;
        //         this.stop = stop;
        //     }

        //     [Symbol.iterator]() {
        //         return this;
        //     }

        //     next() {
        //         var value = this.value;
        //         if (value < this.stop) {
        //             this.value++;
        //             return {
        //                 done: false,
        //                 value: value
        //             }
        //         } else {
        //             return {
        //                 done: true,
        //                 value: undefined
        //             }
        //         }
        //     }
        // }

        // function range(start, stop) {
        //     return new RangeIterator(start, stop);
        // }


        function* range(start, stop) {
                for (var i = start; i < stop; i++) {
                    yield i;
                }
            }
            // 上面这 4 行代码就可以完全替代之前的那个 23 行的实现，替换掉整个 RangeIterator 类，这是因为 Generator 天生就是迭代器，所有的 Generator 都原生实现了 .next() 和 [Symbol.iterator]() 方法。你只需要实现其中的循环逻辑就够了。

        for (var value of range(0, 3)) {
            console.log(value);
        }
    })();
    </script>
</body>

</html>
